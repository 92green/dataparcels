import Link from 'gatsby-link';
import {Divider, Grid, GridItem, Text} from 'dcme-style';

## What is it?

Dataparcels lets you edit data structures in an extremely flexible, data-centric way.<br />
It lets you traverse your data structures like [Immutable.js](https://facebook.github.io/immutable-js/) does, but with added two-way data binding magic. You can trigger changes to small parts of your data, and those changes will propagate back up and merge into the original data shape automatically.

When your data is held in React state, this can form the basis of almost any interactive user interface you can think of.

It's designed for use with [React](https://reactjs.org/), and comes with hooks for easy state management and performant rendering. The heirarchical, componentized nature of React fits perfectly with the heirarchical, componentized nature of dataparcels.

**[See an example of dataparcels code in action](/ui-behaviour#Drag-and-drop-sorting)**.

<Divider />

## Getting Started

<Link to="/getting-started">Get started with dataparcels</Link>, installation instructions and a first example.

<Divider />

## Features

### 1. Data editing

<Link to="/data-editing">Data editing</Link> is the ability to manipulate data based on user input. This includes:
- <Link to="/data-editing">Data traversal</Link>
- <Link to="/data-editing">Binding data to inputs</Link>
- <Link to="/data-editing">Merging partial changes</Link> into larger data structures
- Methods for working with <Link to="/data-editing#Indexed-data-types">indexed data types</Link> such as arrays
- <Link to="/data-editing#Indexed-data-types">Automatic unique keying</Link> of array elements
- Ability to <Link to="/data-editing#Modifying-data-to-fit-the-UI">modify data to fit the UI</Link>
- Setting <Link to="/data-editing#Derived-data">derived data</Link> based on other data
- <Link to="/data-editing#Fields-that-interact-with-each-other">Fields that interact with each other</Link>
- <Link to="/data-editing#Managing-your-own-Parcel-state">Managing your own Parcel state</Link>

### 2. UI behaviour

<Link to="/ui-behaviour">UI behaviour</Link> covers features that help the user interact with the data. This includes:
- Creating forms with [submit buttons](/ui-behaviour#Submitting-forms) or [autosave](/ui-behaviour#Autosaving-forms)
- <Link to="/ui-behaviour#Validation-on-user-input">Validation on user input</Link>
- <Link to="/ui-behaviour#Confirmation">Confirmation</Link> on important actions such as deleting
- <Link to="/ui-behaviour#Selections">Selections</Link> of one or more items
- <Link to="/ui-behaviour#Drag-and-drop-sorting">Drag and drop sorting</Link> of arrays of items
- <Link to="/ui-behaviour#Debouncing-changes">Debouncing changes</Link> for improved performance
- <Link to="/ui-behaviour#Pure-rendering">Pure rendering</Link> for improved rendering performance

### 3. Data synchronisation

Data synchronisation encompasses how dataparcels interacts with pieces of data stored externally.

**This part of the library is being developed and will be complete soon.**

<Divider />

## Development

Dataparcels is written and maintained by [Damien Clarke](https://damienclarke.me/), with feedback from [Allan Hortle](https://github.com/allanhortle) and others at [Blueflag](https://blueflag.com.au/about-us/).
All online library discussion happens over on [Github](https://github.com/blueflag/dataparcels).

As this library matures I intend to make it easier for other to help out, such as guidelines for contributing, design rules and philosophies this library uses, developement setup, and details on dataparcels internal architecture.

I hope this library helps solve some front-end problems for you.

### Roadmap

- Add **revertable changes**. The `useParcelState.onChange` callback should be able to return promises, and this can then allow failed `onChange` calls to reinstate unsaved changes in a lower Parcel buffer. This is a crucial feature that will allow for forms to rollback when requests fail.
- Add **data synchronisation docs**, including data sync strategies strategies with examples.
- Add **merge mode** to control how downward changes are accepted into `ParcelBoundary` components. This is required for rekey.
- Add **rekey**, which enables changes via props to be merged into buffered changes (i.e. unsaved changes). This will allow multiple editors to alter the same piece of data simultaneously without overwriting. The ability to rebase unsaved changes onto updated data already exists, but rekey is required to make sense of incoming changes via props.
- Add **cache**, an option in `useParcelBuffer` to save, reload and clear cached data. This can be used with `localStorage` or similar external storage mechanisms to retain and restore unsaved changes.
- Add **production builds**, a proper build process that doesn't rely on minification and dead code elimination being carried out by the containing project's build process. This step will finally allow proper optimisations to reduce bundle size.
