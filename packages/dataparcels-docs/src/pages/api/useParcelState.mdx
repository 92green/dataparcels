import Link from 'component/Link';
import ApiPageIcon from 'component/ApiPageIcon';
import Icon from 'assets/parcelhoc.gif';
import {Break} from 'dcme-style';
import {DocsSectionHeading} from 'dcme-style';
import {Message} from 'dcme-style';
import ValueUpdater from 'docs/notes/ValueUpdater.md';

# useParcelState

<ApiPageIcon>{Icon}</ApiPageIcon>

The useParcelState function is a React hook. Its job is to provide you with a [Parcel](/api/Parcel) stored in React state, and to handle how the parcel responds to changes in React props.

By default, useParcelState operates in a similar way to an [uncontrolled component](https://reactjs.org/docs/uncontrolled-components.html), accepting an initial value once on first mount, and then becoming the master of its own state from then on. This behaviour can be changed using the [updateValue](#updateValue) parameter.

```js
import useParcelState from 'react-dataparcels/useParcelState';
```

```flow
let [parcel] = useParcelState({
    value: any,
    // optional
    updateValue?: boolean,
    rebase?: boolean,
    onChange?: Function,
    beforeChange?: Function|Function[]
});
```

<Message>If you want a submittable form, consider using <Link to="/api/useParcelForm">useParcelForm</Link>.</Message>

<Break />

## <DocsSectionHeading>Params</DocsSectionHeading>

### value

```flow
value: any
```

Sets the initial value to be put into useParcelState's Parcel.

```js
let [parcel] = useParcelState({
    value: 100
});

// parcel.value is 100

parcel.set(200);

// set() triggers a change and a re-render
// parcel.value is now 200
```

If computing `value` is a heavy operation, you can return the value from a function. The function will only be called on initial mount. However, if `updateValue` is set to true then the function will be called on every update.

```js
let [parcel] = useParcelState({
    value: () => 100
});

// parcel.value is 100
```

### updateValue

```flow
updateValue?: boolean = false // optional
```

When `updateValue` is set to true during an update, the useParcelState hook will check to see if `value` has changed, and will update its Parcel's value if so. This will completely replace any changes that may have happened to the Parcel since the last time `value` was put into the Parcel.

Note that it will also cause any downstream [useParcelBuffer](/api/useParcelBuffer#parcel) hooks and [ParcelBoundaries](/api/ParcelBoundary#parcel) to forget all their buffered changes, unless [rebase](#rebase) is used.

Value changes are detected using `Object.is()`, comparing the new `value` with the previous one.

```js
// receivedValue is 100

let [parcel] = useParcelState({
    value: receivedValue,
    updateValue: true
});

// parcel.value is 100

parcel.set(200);

// set() triggers a change and a re-render
// parcel.value is now 200

// if component updates and receivedValue is now 300
// then parcel.value is now 300
```

### rebase

```flow
rebase?: boolean = false // optional
```

As described above, updates caused by `updateValue` will cause any downstream [useParcelBuffer](/api/useParcelBuffer#parcel) hooks and [ParcelBoundaries](/api/ParcelBoundary#parcel) to forget all their buffered changes. This is safe default behaviour because changes in the downstream buffers may not be compatible with the new Parcel's data shape. However it may be user unfriendly in some cases, depending on when and how often the parcel updates.

Setting `rebase` to true will prevent downstream buffers from being cleared.

#### Please note

Only use this if the shape of your data does not change, so that downstream buffered changes are compatible with the new Parcel's data shape.

This restriction will be lifted in future with the introduction of a feature known as *rekey*.

### onChange

```flow
onChange?: (parcel: Parcel, changeRequest: ChangeRequest) => void // optional
```

If provided, this function is called whenever useParcelState's Parcel has handled a change. It receives the new [Parcel](/api/Parcel), and the [ChangeRequest](/api/ChangeRequest) that was responsible for the change.

This function can be used to relay changes further up the React heirarchy.

Please keep in mind that it is possible for a change to result in the same data being contained in the Parcel, `onChange` will not dedupe subsequent calls whose Parcels contain the same data.

```js
let [parcel] = useParcelState({
    value: receivedValue,
    onChange: (parcel, changeRequest) => {
        // add logic here
    }
});
```

### beforeChange

```flow
beforeChange?: ParcelValueUpdater|ParcelValueUpdater[] // optional

type ParcelValueUpdater = (value: any, changeRequest: ChangeRequest) => any
type ParcelValueUpdater = asShape((parcelShape: ParcelShape, changeRequest: ChangeRequest) => any);
```

The `beforeChange` parameter accepts either a single function, or an array of functions. Whenever a new `value` is taken into useParcelState from params, and whenever the useParcelState hook recieves a change from below, the change is passed through each `beforeChange` function.

Internally the useParcelBuffer hook uses [Parcel.modifyUp()](/api/Parcel#modifyUp()) on each of the `beforeChange` functions. If more than one function is passed to `beforeChange`, the change will go through the first function in the array first, then the second etc.

This is particularly useful for setting [derived data](data-editing#Deriving-meta), and plugins such as [validation](/api/validation) are built to be passed into `beforeChange`.

<ValueUpdater />

```js
let [parcel] = useParcelState({
    value: "ABC",
    beforeChange: value => value.toLowerCase()
});

// ^ "ABC" will be passed through `beforeChange`
// and useParcelState's Parcel will contain a value of "abc"
// parcel.value is now "abc"

parcel.set("HELLO");

// ^ "HELLO" will be passed through `beforeChange`
// and useParcelState's Parcel will contain a value of "hello"
// parcel.value is now "hello"
```

## <DocsSectionHeading>Returns</DocsSectionHeading>

```flow
[parcel: Parcel]
```

### parcel

```flow
parcel: Parcel
```

The useParcelState hook returns an array containing a single element, the Parcel that it holds in React state.
