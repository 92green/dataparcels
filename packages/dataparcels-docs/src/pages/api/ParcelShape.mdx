import IndexedKeys from 'docs/notes/IndexedKeys.md';
import ValueUpdater from 'docs/notes/ValueUpdater.md';
import {Box} from 'dcme-style';
import {Break} from 'dcme-style';
import {DocsSectionHeading} from 'dcme-style';
import {Link} from 'dcme-style';
import {Message} from 'dcme-style';
import {Param} from 'dcme-style';
import {Text} from 'dcme-style';
import ApiPageIcon from 'component/ApiPageIcon';
import IconParcelShape from 'assets/parcelshape.gif';

# ParcelShape, asShape

## asShape

<ApiPageIcon>{IconParcelShape}</ApiPageIcon>

The `asShape` function is a kind of [parcel updater](/parcel-updaters) that allows for advanced editing of a data shape while retaining key and meta information. It returns a `ParcelShape` that contains your parcel's data.

It must be passed a function, whose first argument will be a `ParcelShape`. It will sometimes receive a [ChangeRequest](/api/ChangeRequest) as a second parameter depending on what the `asShape()` function is being passed into.

Your updater function should either return another ParcelShape, or if you return anything else, this value will be used instead.

```js
import asShape from 'dataparcels/asShape';
import asShape from 'react-dataparcels/asShape';
```

```js
let parcel = new Parcel({
    value: [1,2,3]
});

let modifiedParcel = parcel.modifyDown(asShape(
    shape => shape
        .unshift(0)
        .push(4)
));

// modifiedParcel.value is [0,1,2,3,4]
```

## ParcelShape

ParcelShape is a data container very similar to a [Parcel](/api/Parcel) but without the automatic data binding. All it does is contain data, no strings attached, and provide methods for you to alter its data.

ParcelShape's methods are roughly a subset of [Parcel](/api/Parcel)'s methods.

```js
import ParcelShape from 'dataparcels/ParcelShape';
import ParcelShape from 'react-dataparcels/ParcelShape';
```

```flow
new ParcelShape(value?: any);
```

* <Param name="value" optional type="any" default="undefined" />
  The value you want to put in the ParcelShape. This value will be changed immutably when change methods are called on the ParcelShape. The data type of the `value` will determine the type of ParcelShape that will be created, and will determine which methods you can use to change the value. Please read <Link to="/parcel-types">Parcel types</Link> for more info.

```js
// creates a Parcel that contains a value of 123
let shape = new ParcelShape(123);
```

ParcelShapes are used in a very similar way to [Immutable.js Maps and Lists](https://facebook.github.io/immutable-js/docs/), by calling methods that return new and updated ParcelShapes.

```js
let modifiedParcel = parcel.modifyDown(asShape(
    shape => shape
        .unshift(0)
        .push(4)
        .update(0, value => value * 10)
));
```

## <DocsSectionHeading>Properties</DocsSectionHeading>

### value

```flow
value: any
```

Returns the ParcelShape's value.

### meta

```flow
meta: Object
```
Returns an object containing the ParcelShapes's meta data.

### data

```flow
data: Object
```

Returns an object containing the ParcelShapes's data, which includes:
* `value` - The ParcelShapes's value
* `meta` - The ParcelShapes's [meta object](/parcel-meta)
* `key` - The ParcelShapes's [key](/parcel-keys)
* `child` - The ParcelShapes's child information, which includes any `meta`, `key` and `child` data related to the `value`s children.

### key

```flow
key: string
```

```flow
key: string
```

Returns the ParcelShape's `key`. Dataparcels automatically gives unique keys to all children of a parent parcel. See [parcel keys](/parcel-keys) for more info.

## <DocsSectionHeading>Parent methods</DocsSectionHeading>

### get()

```flow
get(key: string|number): ParcelShape // only on ParentParcels
get(key: string|number, notSetValue: any): ParcelShape // only on ParentParcels
```

Returns a ParcelShape containing the value associated with the provided key / index.
If the key / index doesn't exist, a ParcelShape with a value of `notSetValue` will be returned.
If `notSetValue` is not provided then a ParcelShape with a value of
 `undefined` will be returned.

```js
let value = {
    abc: 123,
    def: 456
};
let shape = new ParcelShape(value);
shape.get('abc').value; // returns 123
shape.get('xyz').value; // returns undefined
shape.get('xyz', 789).value; // returns 789
```

#### get() with indexed values

<IndexedKeys />

```js
let value = ['abc', 'def', 'ghi'];
let shape = new ParcelShape(value);
shape.get(0).value; // returns 'abc'
shape.get(-1).value; // returns 'ghi'
shape.get('#a').value; // returns 'abc'
```

### getIn()

```flow
getIn(keyPath: Array<string|number>): ParcelShape // only on ParentParcels
getIn(keyPath: Array<string|number>, notSetValue: any): ParcelShape // only on ParentParcels
```

Returns a ParcelShape containing the value associated with the provided key path.
If the key path doesn't exist, a ParcelShape with a value of `notSetValue` will be returned.
If `notSetValue` is not provided then a ParcelShape with a value of
 `undefined` will be returned.

```js
let value = {
    a: {
        b: 123
    }
};
let shape = new ParcelShape(value);
shape.get(['a','b']).value; // returns 123
shape.get(['a','z']).value; // returns undefined
shape.get(['a','z'], 789).value; // returns 789
```

<IndexedKeys />

### children()

```flow
children(): ParentType<ParcelShape> // only on ParentParcels
```

Returns all of the ParcelShape's children as new ParcelShapes, contained within the original ParcelShape's data structure.

```js
let value = {
    abc: 123,
    def: 456
};

let shape = new ParcelShape(value);
shape.children();

// returns {
//    abc: ParcelShape, // contains a value of 123
//    def: ParcelShape // contains a value of 456
// }

```

### toArray()

```flow
toArray(): Object<Parcel> // only on parent ParcelShapes
```

Like [children()](#children()), expect the returned data structure is cast to an array.

### has()

```flow
has(key: string|number): boolean // only on ParentParcels
```

Returns true if the ParcelShape has a child at the provided `key` or `index`, or false otherwise.

### size()

```flow
size(): number // only on ParentParcels
```

Returns the number of children this ParcelShape has.

## <DocsSectionHeading>Set methods</DocsSectionHeading>

### set()

```flow
set(value: any): ParcelShape
```

Calling `set()` will return a new ParcelShape where the original value is replaced with the `value` provided.

```js
let shape = new ParcelShape(123);
shape.set(456);
// returns a new ParcelShape containing 456
```

<IndexedKeys />

### delete()

```flow
delete(): ParcelShape
delete(key: string|number): ParcelShape // only on ParentParcels, will delete a child
```

Calling `delete()` with no arguments will delete the current ParcelShape off of its parent. This variation of the `delete()` method only exists on ChildParcels.

On ParentParcels this method can be called with a `key`, which deletes the child value at that key.

<IndexedKeys />

### update()

```flow
type ParcelUpdater = (value: any) => any;

// updates value - only to be used if shape doesn't change
update(updater: ParcelUpdater): Parcel

// updates shape, including meta
update(asChildNodes(updater: ParcelUpdater)): Parcel
update(asShape(updater: ParcelUpdater)): Parcel

// updates value on child - only to be used if shape doesn't change
update(key: string|number, updater: ParcelUpdater): Parcel // only on ParentParcel

// updates shape on child, including meta
update(asChildNodes(key: string|number, updater: ParcelUpdater)): Parcel // only on ParentParcel
update(asShape(key: string|number, updater: ParcelUpdater)): Parcel // only on ParentParcel
```

Calling `update()` with one argument will replace the current value in the ParcelShape with the result of the value updater provided to it. The value updater is passed the current value of the ParcelShape, from which you can return the intended replacement value.

On ParentParcels this method can also be called with a `key`, which updates the child value at that key. The value updater is passed the current value found at the `key`, from which you can return the intended replacement value.

<ValueUpdater />

### map()

```flow
type ParcelUpdater = (value: any) => any;

// updates values on children - only to be used if shape doesn't change
update(updater: ParcelUpdater): Parcel // only on ParentParcel

// updates shapes on children, including meta
update(asChildNodes(updater: ParcelUpdater)): Parcel // only on ParentParcel
update(asShape(updater: ParcelUpdater)): Parcel // only on ParentParcel
```

The `map()` function will update every child value. It is passed each child value in order, from which you can return each intended replacement value.

<ValueUpdater />

### setMeta()

```flow
setMeta(partialMeta: Object): ParcelShape
```

Sets `meta` at the current parcel's location. Values on the `partialMeta` object are merged shallowly onto any existing `meta`. Read [Parcel meta](/parcel-meta) for more info.

## <DocsSectionHeading>Indexed and element change methods</DocsSectionHeading>

### insertAfter()

```flow
insertAfter(value: any): ParcelShape // only on ElementParcels, will insert after self
insertAfter(key: string|number, value: any): ParcelShape // only on IndexedParcels, will insert after child
```

When called with one argument, this inserts `value` after the current Parcel, within the current ParentParcel.

When called with two arguments, this inserts `value` after the child Parcel at `key`.

<IndexedKeys />

### insertBefore()

```flow
insertBefore(value: any): ParcelShape // only on ElementParcels, will insert before self
insertBefore(key: string|number, value: any): ParcelShape // only on IndexedParcels, will insert before child
```

When called with one argument, this inserts `value` before the current Parcel, within the current ParentParcel.
When called with two arguments, this inserts `value` as the next sibling Parcel before the child Parcel at `key`.

<IndexedKeys />

### push()

```flow
push(...values: Array<*>): ParcelShape // only on IndexedParcels
```

This triggers a change that pushes all provided values to the end of the current ParentParcel.

### pop()

```flow
pop(): ParcelShape // only on IndexedParcels
```

This triggers a change that pops the last value off of the end of the current ParentParcel.

### shift()

```flow
shift(): ParcelShape // only on IndexedParcels
```

This triggers a change that pops the first value off of the start of the current ParentParcel.

### unshift()

```flow
unshift(...values: Array<*>): ParcelShape // only on IndexedParcels
```

This triggers a change that unshifts all provided values to the start of the current ParentParcel.

## <DocsSectionHeading>Type methods</DocsSectionHeading>

### isChild()

```flow
isChild(): boolean
```

Returns true if the parcel is a child parcel. Read [Parcel types](/parcel-types) for more info.

When a parcel is a child parcel, it allows the use of [child methods](#Child-methods).

### isElement()

```flow
isElement(): boolean
```

Returns true if the parcel is an element parcel. Read [Parcel types](/parcel-types) for more info.

When a parcel is an element parcel, it allows the use of [element methods](#Indexed-and-element-change-methods).

### isIndexed()

```flow
isIndexed(): boolean
```

Returns true if the parcel is an indexed parcel. Read [Parcel types](/parcel-types) for more info.

When a parcel is an indexed parcel, it allows the use of [indexed methods](#Indexed-and-element-change-methods).

### isParent()

```flow
isParent(): boolean
```

Returns true if the parcel is a parent parcel. Read [Parcel types](/parcel-types) for more info.

When a parcel is a parent parcel, it allows the use of [branch methods](#Branch-methods) and [parent methods](#Parent-methods).

### isTopLevel()

```flow
isTopLevel(): boolean
```

Returns true if the parcel is a top level parcel. Read [Parcel types](/parcel-types) for more info.
