import Link from 'gatsby-link';
import SubmitButton from 'examples/SubmitButton';
import SubmitButtonSource from 'examples/SubmitButtonSource.txt';
import Autosave from 'examples/Autosave';
import AutosaveSource from 'examples/AutosaveSource.txt';
import ValidationExample from 'examples/ValidationExample';
import ValidationExampleSource from 'examples/ValidationExampleSource.txt';
import EditingArraysDrag from 'examples/EditingArraysDrag';
import EditingArraysDragSource from 'examples/EditingArraysDragSource.txt';
import ParcelBoundaryDebounce from 'examples/ParcelBoundaryDebounce';
import ParcelBoundaryDebounceSource from 'examples/ParcelBoundaryDebounceSource.txt';
import ParcelBoundaryPure from 'examples/ParcelBoundaryPure';
import ParcelBoundaryPureSource from 'examples/ParcelBoundaryPureSource.txt';
import ParcelMetaConfirmingDeletions from 'examples/ParcelMetaConfirmingDeletions';
import ParcelMetaConfirmingDeletionsSource from 'examples/ParcelMetaConfirmingDeletionsSource.txt';
import ParcelMetaSelections from 'examples/ParcelMetaSelections';
import ParcelMetaSelectionsSource from 'examples/ParcelMetaSelectionsSource.txt';
import {Code} from 'dcme-style';
import {Divider} from 'dcme-style';

# UI behaviour

UI behaviour covers features that help the user interact with data.

## Submitting forms

Dataparcels is very often used with data that's fetched from a server, and saved back to a server. When dataparcels is used like this, it's useful to prevent the user's changes from being immediately sent back to the server and instead hold onto them momentarily. We can either wait for the user to choose to send their changes, or wait until an amount of time has passed since the user has made a change, and *then* save the changes to the server.

The [useParcelForm](/api/useParcelForm) hook makes this easy to set up.

In an actual app you would still need to configure the `useParcelState` hook to send the changes to the server. [Data Synchronisation](/data-synchronisation) will describe how that can be done.

<SubmitButton />
<Code language="jsx">{SubmitButtonSource}</Code>

## Autosaving forms

<Autosave />
<Code language="jsx">{AutosaveSource}</Code>

<Divider />

## Validation on user input

Dataparcels' [validation plugin](/api/validation) provides an easy way to test whether data conforms to a set of validation rules, show errors to the user, and prevent changes from being submitted until the data is valid.

Try removing the value of the `name` field, or choosing a non-numeric or negative value for the amount of animals.

<ValidationExample />
<Code language="jsx">{ValidationExampleSource}</Code>

<Divider />

## Confirmation

This example shows how to display a confirmation message with options. Try deleting an item in the demo below.

This uses [parcel meta](/parcel-meta), a generic way of storing extra data that pertains to parts of a data shape. In this case, `confirming` is being stored against each element in the array.

<ParcelMetaConfirmingDeletions />
<Code language="jsx">{ParcelMetaConfirmingDeletionsSource}</Code>

### What's going on
* Clicking on an "x" button sets the `meta.confirming` state to `true`, which renders a choice of two buttons.
* "No" sets `meta.confirming` back to false again, while "Yes" calls [delete()](/api/Parcel#delete) method on the Parcel.
* Notice how the meta always relates to the correct element, even if other elements are deleted.

<Divider />

## Selections

This example shows how to use meta stored against each element in an array to keep track of which items have been selected.

<ParcelMetaSelections />
<Code language="jsx">{ParcelMetaSelectionsSource}</Code>

<Divider />

## Drag and drop sorting

Drag and drop is easy using [react-dataparcels-drag](https://www.npmjs.com/package/react-dataparcels-drag), which is a slim wrapper around [react-sortable-hoc](https://github.com/clauderic/react-sortable-hoc). Drag items up and down to change their order.

The `react-dataparcels-drag` hoc attempts to keep a very similar API to `react-sortable-hoc`, and therefore its usage is a little different compared to the other hocs in `react-dataparcels`.

<EditingArraysDrag />
<Code language="jsx">{EditingArraysDragSource}</Code>

<Divider />

## Debouncing changes

Debouncing can be used to increase rendering performance for parcels that change value many times in rapid succession, such as text inputs. This feature is available through use of [ParcelBoundary](/api/ParcelBoundary#debounce) and [useParcelBuffer](/api/useParcelBuffer#debounce).

Debouncing can be good for rendering performance because parcels outside the ParcelBoundary don't needlessly update every time a small change occurs (e.g. each time the user presses a key).

<ParcelBoundaryDebounce />
<Code language="jsx">{ParcelBoundaryDebounceSource}</Code>

<Divider />

## Pure rendering

Pure rendering is achieved automatically through the use of [ParcelBoundaries](/api/ParcelBoundary). In this example, ParcelBoundaries render as coloured boxes. As you type in an input, the colours will change to indicate which ParcelBoundaries have re-rendered.

<ParcelBoundaryPure />
<Code language="jsx">{ParcelBoundaryPureSource}</Code>
