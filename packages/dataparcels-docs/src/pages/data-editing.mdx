import Link from 'gatsby-link';
import EditingObjects from 'examples/EditingObjects';
import EditingObjectsSource from 'examples/EditingObjectsSource.txt';
import EditingArrays from 'examples/EditingArrays';
import EditingArraysSource from 'examples/EditingArraysSource.txt';
import EditingModifyAlphanumeric from 'examples/EditingModifyAlphanumeric';
import EditingModifyAlphanumericSource from 'examples/EditingModifyAlphanumericSource.txt';
import EditingModifyNumber from 'examples/EditingModifyNumber';
import EditingModifyNumberSource from 'examples/EditingModifyNumberSource.txt';
import EditingModifyDelimited from 'examples/EditingModifyDelimited';
import EditingModifyDelimitedSource from 'examples/EditingModifyDelimitedSource.txt';
import EditingModifyMissing from 'examples/EditingModifyMissing';
import EditingModifyMissingSource from 'examples/EditingModifyMissingSource.txt';
import DerivedValue from 'examples/DerivedValue';
import DerivedValueSource from 'examples/DerivedValueSource.txt';
import DerivedMeta from 'examples/DerivedMeta';
import DerivedMetaSource from 'examples/DerivedMetaSource.txt';
import InteractingFields from 'examples/InteractingFields';
import InteractingFieldsSource from 'examples/InteractingFieldsSource.txt';
import ManagingOwnParcelState from 'examples/ManagingOwnParcelState';
import ManagingOwnParcelStateSource from 'examples/ManagingOwnParcelStateSource.txt';
import {Code} from 'dcme-style';
import {Divider} from 'dcme-style';
import {Message} from 'dcme-style';

# Data Editing

Data editing is the ability to manipulate data based on user input.

The core of dataparcels' flexible data editing capabilities come from its [Parcel](/api/Parcel) class and methods. It provides methods to let you **traverse data structures** and **bind data to inputs**, so each input is connected to a specific piece of data in the Parcel. Any changes that occur in each input are propagated back to the top level Parcel, which takes care of **merging partial changes** back into the original data structure.

#### useParcelState vs useParcelForm

All of the examples on this page use the useParcelState hook, which works very well for simple storage of a Parcel in React state. If you'd like to make something more like a typical form with a submit action, take a look at the examples in the next section on [UI behaviour](/ui-behaviour).

## Editing collections

Say we want to allow the user to edit the fields in the following data structure:

```js
{
    firstname: "Robert",
    lastname: "Clamps",
    address: {
        postcode: "1234"
    }
}
```

This example demonstrates a pretty typical React setup to do that.

<EditingObjects />
<Code language="jsx">{EditingObjectsSource}</Code>

### What's going on

* `react-dataparcels` is imported.
* It stores the data in state using the [useParcelState](/api/useParcelState) hook. The parcel contains the data.
* The `.get()` and `getIn()` methods are used on the Parcel to create smaller parcels containing just `firstname`, `lastname` and `postcode` respectively.
* It uses the [ParcelBoundary](/api/ParcelBoundary) React component to avoid needless re-rendering. This isn't *required*, but it is very recommended.
* Finally `.spreadDOM()` is used to provide the `value` and `onChange` props to the `input` elements.

For the full list of methods you can use to traverse and change Parcels, see [Branch Methods](/api/Parcel#branch_methods), [Input Binding Methods](/api/Parcel#Input-binding-methods) and [Change Methods](/api/Parcel#Change-methods) in the Parcel API reference.

<Divider />

## Indexed data types

Dataparcels has a powerful set of methods for manipulating indexed data types, such as arrays. This example demonstrates an editor that allows the user to edit, append to and sort the elements in an array of strings.

Notice how items in the array are given **automatic unique keys**, displayed under each input as `#a`, `#b` ..., which can be used by React to identify each element regardless of how the elements move around.

<Message>Make sure you check out the <Link to="/ui-behaviour#Drag-and-drop-sorting">drag and drop sorting</Link> example too.</Message>

<EditingArrays />
<Code language="jsx">{EditingArraysSource}</Code>

### What's going on

* `fruitListParcel` contains an array.
* `Parcel.toArray()` is used to iterate over the Parcel's elements, and it is passed a `mapper` function to return React elements.
* Each element parcel's `key` property is used to uniquely key each React element.
* `ParcelBoundary` is used to ensure great rendering performance.

For the full list of methods you can use on indexed data types, see [Indexed and Element Change Methods](/api/Parcel#Indexed-and-element-change-methods) in the Parcel API reference.

<Divider />

## Modifying data to fit the UI

Sometimes you may hit a situation where a Parcel contains data you want to be able to make an editor for, but the data isn't stored in a format that allows you to do that easily. Parcel's [modifyDown()](/api/Parcel#modifyDown()) and [modifyUp()](/api/Parcel#modifyUp()) methods let you change data types and shapes between the top level Parcel and the input bindings.

### Restricting input characters

This example disallows all non-alphanumeric characters. Try typing some punctuation.

<EditingModifyAlphanumeric />
<Code language="jsx">{EditingModifyAlphanumericSource}</Code>

### Number to string

This example turns a stored number into a string for editing.

#### The keepValue prop

The `keepValue` prop is necessary here. It allows the ParcelBoundary to be the master of its own state.
This is so even when a non-number is entered into the input (e.g. "A"), and this is turned into `NaN` as it passes through `.modifyUp()`, the ParcelBoundary can still remember that it should contain "A". See [ParcelBoundary.keepValue](/api/ParcelBoundary#keepValue) for more details.

<EditingModifyNumber />
<Code language="jsx">{EditingModifyNumberSource}</Code>

### Compensating for missing values

This example show how values can be prepared on the way down, so that rendering the editors can remain simple.

<EditingModifyMissing />
<Code language="jsx">{EditingModifyMissingSource}</Code>

### Editing strings as arrays

This example turns a stored string into an array so array editing controls can be rendered.

<EditingModifyDelimited />
<Code language="jsx">{EditingModifyDelimitedSource}</Code>

<Divider />

## Derived data

It's easy to update Parcel data based on other Parcel data using `beforeChange` available on [useParcelState](/api/useParcelState#beforeChange), [useParcelBuffer](/api/useParcelBuffer#beforeChange) and [ParcelBoundary](/api/ParcelBoundary#beforeChange).

It works quite like [modifyUp()](/api/Parcel#modifyUp()) as shown in [Modifying data to fit the UI](/data-editing#Modifying-data-to-fit-the-UI), but `beforeChange` is also applied to the initial value *and* any updates that occur because of prop changes.

### Deriving a value

This example derives the length of the word.

<DerivedValue />
<Code language="jsx">{DerivedValueSource}</Code>

### Deriving meta

A potential problem with the above example is that it stores derived data in the parcel's *value*. Perhaps the data shape you're editing can not or should not have a new field added to it. It is this reason that [Parcel meta](/parcel-meta) exists, which provides a convenient place to store extra data that pertains to parts of a data shape.

This example also derives the length of the word, but this time it stores it in meta. It also uses a [shape updater](/api/ParcelShape), an advanced editing feature of dataparcels. The shape updater's syntax can look a little strange, but it allows for powerful manipulations of the shape of a value.

<DerivedMeta />
<Code language="jsx">{DerivedMetaSource}</Code>

<Divider />

## Advanced usage

### Fields that interact with each other

Some forms contain fields that influence each other's values. Dataparcels can manage this through the use of `beforeChange`.

This example sums `a` and `b` together. If `a` or `b` are edited, then `sum = a + b`.
If `sum` is edited, `a` and `b` are scaled appropriately so they remain proportional to one another.

<InteractingFields />
<Code language="jsx">{InteractingFieldsSource}</Code>

<Divider />

### Managing your own Parcel state

If you don't want to use the [useParcelState](/api/useParcelState) or [useParcelForm](/api/useParcelForm) hooks, and would prefer to manage your Parcel's state yourself, this example demonstrates how.

This example also serves as an indication on how you might use `dataparcels` with something other than React.

<ManagingOwnParcelState />
<Code language="jsx">{ManagingOwnParcelStateSource}</Code>

### Next

Continue to **[UI behaviour](/ui-behaviour)**.
