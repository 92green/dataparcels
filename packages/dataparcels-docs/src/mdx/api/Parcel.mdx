import IndexedKeys from 'mdx/api/notes/IndexedKeys.md';
import ValueUpdater from 'mdx/api/notes/ValueUpdater.md';

import {Link} from 'dcme-style/affordance';
import Message from 'component/Message';
import Param from 'component/Param';
import ApiPageIcon from 'component/ApiPageIcon';
import IconParcel from 'assets/parcel.gif';
import {Text} from 'dcme-style/affordance';

# Parcel

<ApiPageIcon src={IconParcel} />

Parcel is a data container. Its job is to hold your data, split it into smaller parts, and merge changes back together.

If you're using React, you probably won't be instanciating parcels directly. Please see the [getting started](/getting-started) page to see how to best use Parcels in a React app.

```js
import Parcel from 'dataparcels';
import Parcel from 'react-dataparcels';
```

```flow
new Parcel({
    value?: any,
    handleChange?: Function
});
```

* <Param name="value" optional type="any" default="undefined" />

  The value you want to put in the Parcel. This value will be changed immutably when change methods are called on the Parcel. The data type of the `value` will determine the type of Parcel that will be created, and will determine which methods you can use to change the value. Please read [Parcel types](/concepts/parcel-types) for more info.

* <Param name="handleChange" optional type="(newParcel: Parcel, changeRequest: ChangeRequest) => void" />

  The `handleChange` function will be called whenever the Parcel's value has been triggered to change. It is passed `newParcel`, a replacement Parcel containing the changes; and `changeRequest`, a [ChangeRequest](/api/ChangeRequest) that contains details about the change itself.

  In `handleChange` you would typically implement logic to replace your current parcel with `newParcel`, but if you're using React you should read [getting started](/getting-started) to save you the trouble of implementing this yourself.

```js
// creates a Parcel that contains a value of 123
let parcel = new Parcel({
    value: 123,
    handleChange: (newParcel) => {
        // here you can insert logic to replace
        // your existing parcel with the newParcel
    })
});
```

## <Text textStyle="weaker">Properties</Text>

### value

```flow
value: any
```

Returns the Parcel's value.

```js
let parcel = new Parcel({
    value: 123
});

parcel.value; // returns 123
```

### meta

```flow
meta: Object
```

Returns an object containing the parcel's meta data. Read [Parcel meta](/concepts/parcel-meta) for more info.

```js
let parcel = new Parcel({
    value: 123
});

parcel.meta; // returns {}

// set initial meta and check again
parcel
    .initialMeta({abc: 123})
    .meta; // returns {abc: 123}
```

### data

```flow
data: Object
```

Returns an object containing the Parcel's data, which includes:
* `value` - The Parcel's value
* `meta` - The Parcel's [meta object](/concepts/parcel-meta)
* `key` - The Parcel's [key](/concepts/parcel-keys)
* `child` - The Parcel's child information, which includes any `meta`, `key` and `child` data related to the `value`s children.

```js
let parcel = new Parcel({
    value: 123
});
parcel.data;

// return {
//     child: undefined,
//     key: '^',
//     meta: {},
//     value: 123,
// }
```

### key

```flow
key: string
```

Returns the Parcel's `key`. Dataparcels automatically gives unique keys to all children of a parent parcel. See [parcel keys](/concepts/parcel-keys) for more info.

Because they are unique, the can be used as keys when rendering an array of elements with React. This is demonstrated [here](/data-editing#Indexed-data-types).

```js
let parcel = new Parcel({
    value: {
        abc: 123,
        def: 456
    }
});

parcel.get("abc").key; // returns "abc"
```

```js
let parcel = new Parcel({
    value: [
        123,
        456
    ]
});

parcel.get(0).key; // returns "#0"
```

### type

```flow
type: string
```

Returns a string of the type of data that Parcel.value contains.

By default this is `"basic"`, `"object"` or `"array"`, but can have other values if custom types are being used.

```js
let parcel = new Parcel({
    value: [
        123,
        456
    ]
});

parcel.type; // returns "array"
```

### parentType

```flow
parentType: string
```

Returns a string of the type of data that the parent Parcel.value contains. So a parcel containing the element of an array would have a `parentType` of `"array"`.

By default this is `"object"` or `"array"`, but can have other values if custom types are being used.

```js
let parcel = new Parcel({
    value: [
        123,
        456
    ]
});

parcel.get(0).parentType; // returns "array"
```

### id

```flow
id: string
```

Returns the Parcel's `id`. Under most circumstances, `id`s are unique among all Parcels that are descendants of a single original Parcel. You won't often need to use this, but it can sometimes be useful for debugging.

### path

```flow
path: string[]
```

Returns the Parcel's `path`, an array of strings indicating how to access the current Parcel's value.

```js
let parcel = new Parcel({
    value: {
        abc: {
            def: 123
        }
    }
});

parcel.get("abc").get("def").path; // returns ["abc", "def"]
```

### isParent

```flow
isParent: boolean
```

Is true if the parcel is a parent parcel. Read [Parcel types](/concepts/parcel-types) for more info.

When a parcel is a parent parcel, it allows the use of [branch methods](#Branch-methods) and [parent methods](#Parent-methods).

### isChild

```flow
isChild: boolean
```

Is true if the parcel is a child parcel. Read [Parcel types](/concepts/parcel-types) for more info.

When a parcel is a child parcel, it allows the use of [child methods](#Child-methods).

### size

```flow
size: number
```

The number of children this Parcel has. If the parcel is not a parent parcel, `size` will be `0`.

## <Text textStyle="weaker">Parent-type methods</Text>

### has()

```flow
has(key: string|number): boolean // only on ParentParcels
```

Returns true if the Parcel has a child at the provided `key` or `index`, or false otherwise.

## <Text textStyle="weaker">Branch methods</Text>

### get()

```flow
get(key: string|number): Parcel // only on ParentParcels
get(key: string|number, notSetValue: any): Parcel // only on ParentParcels
```

Returns a Parcel containing the value associated with the provided key / index.
If the key / index doesn't exist, a Parcel with a value of `notSetValue` will be returned.
If `notSetValue` is not provided then a Parcel with a value of
 `undefined` will be returned.

```js
let value = {
    abc: 123,
    def: 456
};
let parcel = new Parcel({value});
parcel.get('abc').value; // returns 123
parcel.get('xyz').value; // returns undefined
parcel.get('xyz', 789).value; // returns 789
```

#### get() with indexed values

<IndexedKeys />

```js
let value = ['abc', 'def', 'ghi'];
let parcel = new Parcel({value});
parcel.get(0).value; // returns 'abc'
parcel.get(-1).value; // returns 'ghi'
parcel.get('#0').value; // returns 'abc'
```

### getIn()

```flow
getIn(keyPath: Array<string|number>): Parcel // only on ParentParcels
getIn(keyPath: Array<string|number>, notSetValue: any): Parcel // only on ParentParcels
```

Returns a Parcel containing the value associated with the provided key path.
If the key path doesn't exist, a Parcel with a value of `notSetValue` will be returned.
If `notSetValue` is not provided then a Parcel with a value of
 `undefined` will be returned.

```js
let value = {
    a: {
        b: 123
    }
};
let parcel = new Parcel({value});
parcel.getIn(['a','b']).value; // returns 123
parcel.getIn(['a','z']).value; // returns undefined
parcel.getIn(['a','z'], 789).value; // returns 789
```

<IndexedKeys />

### children()

```flow
children(mapper?: ParcelMapper): ParentType<Parcel> // only on ParentParcels

type ParcelMapper = (
    item: Parcel,
    property: string|number,
    parent: Parcel
) => any;
```

Returns all of the Parcel's children as new ChildParcels, contained within the original Parcel's data structure.

An optional `mapper` function can be passed, which will be called on each child.

```js
let value = {
    abc: 123,
    def: 456
};

let parcel = new Parcel({value});
parcel.children();

// returns {
//    abc: Parcel, // contains a value of 123
//    def: Parcel // contains a value of 456
// }

```

### metaAsParcel()

```flow
metaAsParcel(key: string): Parcel
```

Typically [Parcel meta](/concepts/parcel-meta) is accessed and set via the [.meta](#meta) property and the [.setMeta()](#setMeta()) method. The `metaAsParcel()` function is an alternative that creates a Parcel that controls a piece of meta data. It's useful for binding meta changes to inputs.

```js
let parcel = new Parcel({value: 123});

<input {...parcel.metaAsValue('foo').spreadInput()} />

// if 'bar' is entered in the input, parcel.meta.foo will equal 'bar'
```

## <Text textStyle="weaker">Input binding methods</Text>

### spread()

```flow
spread(): {value: *, onChange: OnChangeFunction}
spread(notFoundValue: any): {value: *, onChange: OnChangeFunction}

type OnChangeFunction = (value: any) => void;
```

This is designed to bind a Parcel with an input component that expects a `value` and an `onChange` callback. The `onChange` callback is expected to pass an updated value as its first argument.

If `notFoundValue` is provided, and the Parcel's value is undefined or has been marked for deletion, the returned value will be equal to `notFoundValue`.

```js
let parcel = new Parcel({
    value: 123
});

<MyInputComponent {...parcel.spread()} />

// ^ this is equivalent to
// <MyInputComponent value={parcel.value} onChange={parcel.set} />

```

### spreadInput()

```flow
spreadInput(): {value: *, onChange: OnChangeFunction}
spreadInput(notFoundValue: any): {value: *, onChange: OnChangeFunction}

type OnChangeFunction = (event: HTMLEvent) => void;
```

This is designed to bind a Parcel with an HTML input. It returns an object with the Parcel's `value` and an `onChange` function.

If `notFoundValue` is provided, and the Parcel's value is undefined or has been marked for deletion, the returned value will be equal to `notFoundValue`.

```js
let parcel = new Parcel({
    value: 123
});

<input {...parcel.spreadInput()} />

// ^ this is equivalent to
// <input value={parcel.value} onChange={event => parcel.set(event.currentTarget.value)} />

```

### spreadCheckbox()

```flow
spreadCheckbox(): {value: *, onChange: OnChangeFunction}
spreadCheckbox(notFoundValue: boolean): {value: *, onChange: OnChangeFunction}

type OnChangeFunction = (event: HTMLEvent) => void;
```

This is designed to bind a Parcel with an HTML checkbox.
It returns an object with `checked` and `onChange`, where `checked` is the Parcel's `value` cast to a boolean, and an `onChange` function.

If `notFoundValue` is provided, and the Parcel's value is undefined or has been marked for deletion, the returned value will be equal to `notFoundValue` cast to a boolean.

```js
let parcel = new Parcel({
    value: 123
});

<input type="checkbox" {...parcel.spreadCheckbox()} />
```

## <Text textStyle="weaker">Change methods</Text>

### set()

```flow
set(value: any): void
```

Calling `set()` will trigger a change that replaces the current value in the Parcel with the `value` provided. This is equivalent to calling [onChange()](#onChange()).

```js
let parcel = new Parcel({
    value: 123
});
parcel.set(456);
// this triggers a change that sets the parcel's value to 456
```

<IndexedKeys />

### delete()

```flow
delete(): void // only on ChildParcels
```

Calling `delete()` will trigger a change that will delete the current Parcel off of its parent. It only exists on ChildParcels.

```js
let value = {
    abc: 123,
    def: 456
};
let parcel = new Parcel({value});
parcel.get('abc').delete();
// this triggers a change that sets the parcel's value to {def: 456}
```

<IndexedKeys />

### update()

```flow
update(updater: ParcelUpdater): void

type ParcelUpdater = ({value, meta}) => ?({value?: any, meta?: Object})
```

Calling `update()` will trigger a change that changes the current value or meta in the Parcel. If other Parcel change methods can't change what you need, the `update()` method probably can.

The `updater` function is passed an object containing the current `value` and `meta`. From here you can return updated data. If nothing is returned from the updater function, no change is made. If an object is returned, it can contain `value` and / or `meta`.

#### Returning a value

If `value` exists on the returned object, this will be the new value of the Parcel.

<ValueUpdater />

```js
let parcel = new Parcel({
    value: 123
});

parcel.update(({value}) => {
    return {
        value: value + 1
    };
});
// this triggers a change that sets the parcel's value to 124
```

#### Returning meta

If a `meta` object exists on the returned object, this will be shallowly merged onto existing meta.

### setMeta()

```flow
setMeta(partialMeta: Object): void
```

Triggers a change that sets `meta` at the current parcel's location. Values on the `partialMeta` object are merged shallowly onto any existing `meta`. Read [Parcel meta](/concepts/parcel-meta) for more info.

```js
let parcel = new Parcel({
    value: "abc"
});

parcel.setMeta({
    abc: 123
});
// ^ this triggers a change that sets the parcel's meta to {abc: 123}

parcel.setMeta({
    def: 456
});
// ^ this triggers a change that sets the parcel's meta to {abc: 123, def: 456}
```

### dispatch()

```flow
dispatch(dispatchable: Action|Action[]|ChangeRequest): void
```

The `dispatch()` method is used by Parcels internally to pass a [ChangeRequest](/api/ChangeRequest) upward to the next Parcel in the chain.

## <Text textStyle="weaker">Array-type properties</Text>

### isFirstChild

```flow
isFirstChild: boolean
```

Is true if this parcel is the first of its siblings.

### isLastChild

```flow
isLastChild: boolean
```

Is true if this parcel is the last of its siblings.

### isOnlyChild

```flow
isOnlyChild: boolean
```

Is true if this parcel is the only child in its parent.

## <Text textStyle="weaker">Array-type change methods</Text>

### insertAfter()

```flow
insertAfter(value: any): void // only on children of array-type parcels, will insert after self
```

This inserts `value` after the current Parcel, within the current ParentParcel.

```js
let parcel = new Parcel({
    value: ['a','b','c']
});

parcel.get(1).insertAfter('!');
// this triggers a change that sets the parcel's value to ['a','b','!','c'];
```

<IndexedKeys />

### insertBefore()

```flow
insertBefore(value: any): void // only on children of array-type parcels, will insert before self
```

This inserts `value` before the current Parcel, within the current ParentParcel.

```js
let parcel = new Parcel({
    value: ['a','b','c']
});

parcel.get(1).insertBefore('!');
// this triggers a change that sets the parcel's value to ['a','!','b','c'];
```

<IndexedKeys />

### moveTo()

```flow
moveTo(newIndex: number): void // only on children of array-type parcels, will move item
```

This takes the parcel from its current position in its parent array, and moves it to `newIndex`.

```js
let parcel = new Parcel({
    value: ['a','b','c','d']
});

parcel.get(3).moveTo(1);
// this triggers a change that sets the parcel's value to ['a','d','b','c'];
```

<IndexedKeys />

### push()

```flow
push(...values: Array<*>): void // only on array-type parcels
```

This triggers a change that pushes all provided values to the end of the current ParentParcel.

```js
let parcel = new Parcel({
    value: ['a','b','c']
});

parcel.push('d','e');
// this triggers a change that sets the parcel's value to ['a','b','c','d','e'];
```

### pop()

```flow
pop(): void // only on array-type parcels
```

This triggers a change that pops the last value off of the end of the current ParentParcel.

```js
let parcel = new Parcel({
    value: ['a','b','c']
});

parcel.pop();
// this triggers a change that sets the parcel's value to ['a','b'];
```

### shift()

```flow
shift(): void // only on array-type parcels
```

This triggers a change that pops the first value off of the start of the current ParentParcel.

```js
let parcel = new Parcel({
    value: ['a','b','c']
});

parcel.shift();
// this triggers a change that sets the parcel's value to ['b','c'];
```

### swapNext()

```flow
swapNext(): void // only on children of array-type parcels, will swap with next sibling
```

This swaps the current Parcel with its next sibling Parcel, within the current ParentParcel. If called on the last child, it swaps with the first child.

```js
let parcel = new Parcel({
    value: ['a','b','c']
});

parcel.get(0).swapNext();
// this triggers a change that sets the parcel's value to ['b','a','c'];
```

<IndexedKeys />

### swapPrev()

```flow
swapPrev(): void // only on children of array-type parcels, will swap with previous sibling
```

This swaps the current Parcel with its previous sibling Parcel, within the current ParentParcel. If called on the first child, it swaps with the last child.

```js
let parcel = new Parcel({
    value: ['a','b','c']
});

parcel.get(1).swapPrev();
// this triggers a change that sets the parcel's value to ['b','a','c'];
```

<IndexedKeys />

### unshift()

```flow
unshift(...values: Array<*>): void // only on array-type parcels
```

This triggers a change that unshifts all provided values to the start of the current ParentParcel.

```js
let parcel = new Parcel({
    value: ['a','b','c']
});

parcel.unshift('d','e');
// this triggers a change that sets the parcel's value to ['d','e','a','b','c'];
```

## <Text textStyle="weaker">Modify methods</Text>

### modifyDown()

```flow
modifyDown(updater: ParcelUpdater): Parcel

type ParcelUpdater = ({value, meta}) => ?({value?: any, meta?: Object})
```

`modifyDown` lets you modify a Parcel's value and / or meta so that subsequent Parcels in the chain receive and make changes against the modified value. It does not trigger any changes of its own, it just modifies the values that pass through it from above. It has no effect on changes being passed upward through it.

The `updater` function is passed an object containing the current `value` and `meta`. From here you can return updated data. If nothing is returned from the updater function, no data is modified. This can be useful for debugging as you can write a `console.log()` in the `modifyDown()` to see what the value is.

If an object is returned, it can contain `value` and / or `meta`.

#### Returning a value

If `value` exists on the returned object, this will be the value of the Parcel returned from `modifyDown()`.

<ValueUpdater />

```js
let parcel = new Parcel({
    value: "abc"
});

parcel
    .modifyDown(({value}) => {
        return {
            value: value.toUpperCase();
        }
    })
    .value // "ABC" (top level Parcel is still "abc")
```

#### Returning meta

If a `meta` object exists on the returned object, this will be shallowly merged onto existing meta.


### modifyUp()

```flow
modifyUp(updater: ParcelUpdater): Parcel

type ParcelUpdater = ({value, meta, changeRequest}) => ?({value?: any, meta?: Object})
```

`modifyUp()` lets you modify a Parcel's new value when a change is being propagated upward. It does not trigger any changes of its own, but awaits a change from below. It has no effect on data being passed down through it.

The `updater` function is passed an object containing the `value` and `meta` that the Parcel is about to change to, and the `changeRequest` that describes how that change is going to occur. From here you can return updated data. If nothing is returned from the updater function, no data is modified. This can be useful for debugging as you can write a `console.log()` in the `modifyUp()` to see what the changed value is.

If an object is returned, it can contain `value` and / or `meta`.

You can also cancel a change.

#### Returning a value

If `value` exists on the returned object, this will alter the value being changed.

<ValueUpdater />

```js
let parcel = new Parcel({
    value: "abc"
});

parcel
    .modifyUp(({value}) => {
        return {
            value: value.toUpperCase()
        };
    });
    .set("def");

// this triggers a change to set the value to "def"
// which propagates upward through .modifyUp()
// .modifyUp() turns "def" into "DEF"
// and the change request continues up to the original Parcel

// The Parcel then has a new value of "DEF"
```

#### Returning meta

If a `meta` object exists on the returned object, this will be shallowly merged onto existing meta.

#### Returning a cancellation

You can also cancel a change by returning [cancel](/api/cancel) from `modifyUp()`'s updater. This allows you to programatically prevent certain changes from being applied to the data in the top level Parcel. This example shows an input that cancels any changes that would set the value to `null`:

```js
import cancel from 'dataparcels/cancel';
// or
import cancel from 'react-dataparcels/cancel';

let parcel = new Parcel({
    value: 123
})

parcel = parcel.modifyUp(({value}) => {
    if(value === null) {
        return cancel
    }
});

parcel.set(456); // this would work, value becomes 123
parcel.set(null); // this would cause no change

```

#### Returning an effect

The `modifyUp` function has the ability to have an effect returned. Effect functions are called after running the updater, and allow for one or more subsequent asynchronous updates to be made to the parcel.

```js
let parcel = new Parcel({
    value: {
        username: ""
    }
})

usernameParcel = parcel
    .get("username")
    .modifyUp(({value}) => {
        return {
            effect: async (update) => {
                let isValid = await validateUsername(value);
                update({
                    meta: {
                        isValid
                    }
                });
            };
        };
    });

usernameParcel.set("myusername");
```

The `effect` function is passed an `update` function that works just like [parcel.update()](#update). In this example, when a username is set the effect will be called and the async function `validateUsername` is called with the new value. Once this resolves, parcel meta is set, indicating if the username is valid.

Please refer to the [promisify](/api/promisify) utility, which simplifies this process when working with promises.

### initialMeta()

```flow
initialMeta(initialMeta: Object): Parcel
```

Parcel `meta` defaults to an empty object. The `initialMeta` method replaces the meta for all descendant Parcels.

Once a descendant Parcel triggers a change, the initial meta is also propagated up to the top level Parcel.

```js
let parcel = new Parcel({
    value: "abc"
});

parcel
    .initialMeta({
        abc: 123
    })
    .meta // this returns {abc: 123} initially, but this can change after subsequent calls to setMeta()

```

## <Text textStyle="weaker">Composition methods</Text>

### pipe()

```flow
pipe(...updaters: Function[]): Parcel
```

The `pipe` method allows for a parcel to be passed through one or more parcel modifying functions, while retaining the ability to chain. It allows for easier function composition.

```js
let valueToString = (parcel) => parcel.modifyDown(value => `${value}`);
let changeToNumber = (parcel) => parcel.modifyUp(value => Number(value));

let parcel = new Parcel({value: 123});
parcel
    .pipe(
        valueToString,
        changeToNumber
    )
    .value // returns "123"
```

The above is equivalent to:

```js
let parcel = new Parcel({value: 123});
parcel
    .modifyDown(value => `${value}`)
    .modifyUp(value => Number(value))
    .value // returns "123"
```
