# Parcel updaters

Several of the methods on [Parcel](/api/Parcel) use callbacks known as "parcel updaters". These functions are used to alter a value based off an existing value. There are a couple of rules around how you can use these updaters.

Parcel updaters are callback functions that are given `value` and `meta` (and sometimes other data), from which you can return updated data. For example, Parcel's `update()` function accepts an updater:

```js
.update(({value}) => {
    return {
        value: value + 10
    };
});
```

You can choose to return `value`, `meta` and sometimes other keys from parcel updaters. You can also usually return nothing or `undefined`, which will mean that the updater has no effect.

Please refer to the documentation on the specific functions that accept parcel updaters to get a definite list of data that is provided and returned.

- [parcel.update()](/api/Parcel#update),
- [parcel.modifyUp()](/api/Parcel#modifyUp)
- [parcel.modifyDown()](/api/Parcel#modifyDown)
- [useParcel source, derive and onChange](/api/useParcel)
- [useBuffer derive](/api/useBuffer#derive)
- [Boundary derive](/api/Boundary#derive).

## Limitations

While most updates are effective and harmless, some ways of changing a value can cause adverse effects.

### Safe

- The updater gives you a primitive value or childless value

```js
stringParcel.update(({value}) => {
    // value is a string
    return {
        value: value + "!"
    };
})

stringParcel.update(({value}) => {
    // value is a string
    return {
        value: [value]
    };
})

dateParcel.update(({value}) => {
    // value is a date
    return {
        value: value.toString()
    };
})
```

- The updater gives you a value that has children, and you return a primitive value or childless value

```js
arrayParcel.update(({value}) => {
    // value is an array of strings
    return {
        value: value.join(".")
    };
})
```

- The updater gives you a value that has children, and you return a value where child items / elements have not changed their keys or indexes

```js
arrayParcel.update(({value}) => {
    // value is an array of numbers
    return {
        value: value.map(number => number + 1)
    };
})
// ^ safe because the shape is still the same

arrayParcel.update(({value}) => {
    // value is an array of numbers
    return {
        value: value.slice(0,3)
    };
})
// ^ safe because elements that remain are still at the same indexes
```

- The updater gives you a value that has children, you can return anything if you don't intend to ever use [branch methods](/api/Parcel#branch-methods) on the parcel you are updating, and therefore never intend to store [Parcel meta](/concepts/parcel-meta) on those child values, or access the children of those child values.

```
arrayParcel.update(({value}) => {
    // value is an array of strings
    return {
        value: ["hello", ...value]
    };
})
// ^ safe ONLY if you never want to call arrayParcel.get(), arrayParcel.children() etc.
```

### Unsafe

- If the updater gives you a value that has children, and you return a value with children whose keys or indexes have changed, *and* you intend to use [branch methods](/api/Parcel#branch-methods) to get those individual children.

```js
arrayParcel.update(({value}) => {
    // value is an array of strings
    return {
        value: value.slice(2)
    };
})
// potentially unsafe, shape has changed because array elements have moved over by 2

arrayParcel.update(({value}) => {
    // value is an array of strings
    return {
        value: value.reverse()
    };
})
// potentially unsafe, shape has changed because array elements have moved around
```

## Why

Dataparcels stores internal keying and meta information against each part of a deep value's data structure. It knows where each part of the data is by remembering the keys of objects and the indexes of arrays. If these keys and indexes were to change in an updater, dataparcels has no way of knowing how each piece of data moved into their new positions. So it can only let you change the value if you promise not to alter the shape.

## Example

```js
// arrayParcel contains a value of [1,2,3]

arrayParcel.get(0).setMeta({cool: true});
// arrayParcel.get(0).meta is now {cool: true}

arrayParcel.update(({value}) => {
    return {
        value: value.slice(1)
    };
})
// arrayParcel.value is now [2,3]

arrayParcel.get(0).meta
// returns {cool: true}
// but {cool: true} should belong to the element that was deleted!
```

You might very well still find yourself in a situation where you need to change keys - this will be solved with the `arrange` utility, to be released soon.
